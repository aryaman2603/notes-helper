Laboratory 3
Synchronization in Operating System
Aim & Objectives
▪ Implement process synchronization using semaphores /
monitors.
▪ Objectives:
▪ To simulate the working of Semaphores (Binary)
▪ To simulate the working of Monitors for any one Classical
synchronization Problems.
Semaphores
▪ A semaphore is a simple integer variable used as a signaling
mechanism to solve synchronization problems.
▪ It ensures that multiple processes can safely access and modify
shared resources without interfering with each other, which could
otherwise lead to incorrect results.
▪ The core issue that semaphores address is the critical section
problem.
Semaphores
▪ A "critical section" is a piece of code where a process accesses a
shared resource (like a shared memory variable, a file, or a
database).
▪ If multiple processes execute this section simultaneously, it can
lead to a "race condition," where the final state of the shared
resource depends on the unpredictable order in which the
processes run, often producing erroneous outcomes.
Semaphores - Working
▪ A semaphore controls access to a shared resource through two
atomic (indivisible) operations :
▪ wait(S): This operation, also known as P(), decrements the
semaphore's integer value S.
▪ If the value becomes less than or equal to zero, the process
that called wait() is blocked and put into a waiting queue.
▪ If the value is positive, the process is allowed to continue into
its critical section.
Semaphores - Working
▪ A semaphore controls access to a shared resource through two
atomic (indivisible) operations :
▪ signal(S): This operation, also known as V(), increments the
semaphore's value S.
▪ If there are any processes waiting for the semaphore, one of
them is unblocked and allowed to proceed.
Semaphores - Types
▪ There are two main types of semaphores:
▪ Counting Semaphore: The value can be any non-negative integer.
It is used to control access to a resource that has multiple
instances. The semaphore is initialized to the number of available
resources.
▪ Binary Semaphore: The value can only be 0 or 1. It functions as a
mutex lock, ensuring that only one process can access a resource
at a time. It is initialized to 1 (available).
Semaphores - pseudocode
signal(Semaphore S)
wait(Semaphore S)
{ {
S = S - 1
S = S + 1
if (S < 0)
if (S <= 0)
{
{
// Block the process
// Remove a process from semaphore's
add process to semaphore's waiting queue
waiting queue
sleep() // Process sleeps until signaled
wakeup(process)
}
// else continue, process enters critical section // Wake up one blocked process
}
}
}
Semaphores – pseudocode - Tracing
Initial Value of Semaphore S = 1 (Semaphore starts unlocked, one resource available), No
Processes waiting
Process 1 or Thread 1 Process 2 or Thread 2
calls wait(S)
S = 1 - 1 = 0;
Since S ≥ 0, P1 or T1 can enter the
critical section immediately.
No blocking occurs. State now: S=0S=0, 0
resources available (busy), 0 waiting
processes.
calls wait(S)
S = 0 – 1 = -1
Since S < 0, P2 or T2 is blocked and added to
the waiting queue.
State now: S = −1, no resources available, 1
process waiting (P2 or T2).
Semaphores – pseudocode - Tracing
Initial Value of Semaphore S = 1 (Semaphore starts unlocked, one resource available), No
Processes waiting
Process 1 or Thread 1 Process 2 or Thread 2
calls signal(S)
S = -1 + 1 = 0;
Since S ≤ 0, one blocked process (P2
or T2) is removed from waiting queue
and resumed.
P2 or T2 can now enter the critical
section.
State now: S = 0, 0 resources available (P2/T2 Eventually P2/T2 calls Signal(S)
in critical section), 0 waiting processes.
S = 0 + 1 = 1
Since S > 0, no waiting processes to wake.
State now: S =1, 1 resource available
(semaphore unlocked), 0 waiting processes.
Semaphores - pseudocode
S = 1: The lock is available.
S = 0: The lock is held by one process.
S < 0: The lock is held, and one or more other processes are
waiting for it.
Semaphores - Example
Includes the libraries for
#include <stdio.h>
input/output, POSIX threads,
#include <pthread.h>
and semaphores.
#include <semaphore.h>
Semaphores - Example
Declares a shared integer
int x = 0;
variable x initialized to 0.
Declares a semaphore mutex to
sem_t mutex;
control access to x.
Semaphores - Example
Defines the function for the thread
void* increment_thread(void* arg) {
that increments x.
sem_wait(&mutex);
sem_wait(&mutex) waits to acquire
x += 5;
the semaphore (lock).
printf("Incremented x to %d\n",
Adds 5 to x.
x);
Prints the new value of x.
sem_post(&mutex);
sem_post(&mutex) releases the
return NULL;
semaphore (unlock).
}
Exits the thread function.
Semaphores - Example
Defines the function for the
void* decrement_thread(void* arg) {
thread that decrements x.
sem_wait(&mutex);
x -= 5;
printf("Decremented x to %d\n", Waits to acquire the semaphore,
x); subtracts 5 from x, prints it,
then releases the semaphore and
sem_post(&mutex);
exits.
return NULL;
}
Semaphores - Example
Main function declares two thread identifiers.
int main() {
Initializes mutex as a binary semaphore with
pthread_t tid1, tid2; initial value 1 (unlocked).
&mutex: This is the address of the
sem_init(&mutex, 0, 1);
semaphore variable to initialize.
0: The pshared parameter. A value of 0
means the semaphore is shared between
threads of the same process only (not
between different processes).
1: The initial value of the semaphore.
Setting it to 1 means it acts as a binary
semaphore (or mutex), allowing only one
thread to enter the critical section at a
time.
Semaphores - Example
Creates two threads, one
pthread_create(&tid1, NULL,
running increment_thread, the
increment_thread, NULL);
other decrement_thread.
pthread_create(&tid2, NULL,
decrement_thread, NULL);
Semaphores - Example
Waits for both threads to
pthread_join(tid1, NULL);
complete before proceeding.
pthread_join(tid2, NULL);
sem_destroy(&mutex); Destroys the semaphore to clean
up resources.
Prints the final value of x after
printf("Final value of x: %d\n", x);
both threads finish.
return 0;
Ends the main program
}
Create Own Semaphores - Code
▪ Create a structure that holds // A simple semaphore
implementation
the integer value, along with a
typedef struct {
mutex and a condition variable,
pthread_mutex_t mutex;
which are standard tools for
pthread_cond_t condition;
building synchronization
int value;
primitives like semaphores.
} semaphore;
Create Own Semaphores - Code
void semaphore_init(semaphore*
▪ semaphore_init: Initializes the
sem, int initial_value) {
semaphore with a starting
value. We use 1 for a binary
pthread_mutex_init(&(sem-
semaphore, meaning one
>mutex), NULL);
resource is available.
pthread_cond_init(&(sem-
>condition), NULL);
sem->value = initial_value;
}
Create Own Semaphores - Code
// The 'wait' operation
▪ semaphore_wait: A thread calls
void semaphore_wait(semaphore* sem) {
this before entering its critical
pthread_mutex_lock(&(sem->mutex));
section. It locks the mutex to
while (sem->value <= 0) {
ensure its check is atomic,
// Wait on the condition variable if
semaphore value is not positive
then checks sem->value. If the
pthread_cond_wait(&(sem->condition),
value is 0, it waits. Otherwise,
&(sem->mutex));
it decrements the value and }
sem->value--;
proceeds.
pthread_mutex_unlock(&(sem->mutex));
Create Own Semaphores - Code
// The 'signal' operation
▪ semaphore_signal: After leaving
void semaphore_signal(semaphore* sem) {
the critical section, the thread
pthread_mutex_lock(&(sem->mutex));
calls this to release the
sem->value++;
resource. It increments sem-
// Signal one waiting thread
>value and signals one of the
pthread_cond_signal(&(sem-
>condition));
waiting threads (if any) to wake
pthread_mutex_unlock(&(sem-
up.
>mutex));
}
Create Own Semaphores - Code
// A function that threads will run
▪ main and thread_function: The
void* thread_function(void* arg) {
semaphore* sem = (semaphore*)arg;
main process and a newly
printf("Thread is trying to acquire the
created thread both compete semaphore...\n");
semaphore_wait(sem);
for the same semaphore. Only
// --- Critical Section Start ---
printf("Thread has acquired the semaphore
one can be in its "critical
and is in the critical section.\n");
// --- Critical Section End ---
section" at any given time,
printf("Thread is releasing the
preventing overlap and
semaphore.\n");
semaphore_signal(sem);
ensuring synchronized access.
return NULL;
}
Create Own Semaphores - Code
int main() { // --- Critical Section End ---
semaphore sem;
// Initialize as a binary semaphore (value
1)
printf("Main process is releasing the
semaphore_init(&sem, 1);
semaphore.\n");
pthread_t thread;
semaphore_signal(&sem);
pthread_create(&thread, NULL,
thread_function, (void*)&sem);
// Wait for the other thread to finish
printf("Main process is trying to acquire the
semaphore...\n");
pthread_join(thread, NULL);
semaphore_wait(&sem);
// --- Critical Section Start ---
printf("Main process has acquired the return 0;
semaphore and is in the critical section.\n");
}
Create Own Semaphores - Code
▪ pthread_mutex_t mutex: A mutex (mutual exclusion
▪ #include <pthread.h>: This
lock). This is used to protect the value field within the
includes the POSIX threads
semaphore itself, ensuring that only one thread can
library. It provides all the modify it at a time. This prevents race conditions inside
our semaphore logic.
necessary functions and data
▪ pthread_cond_t condition: A condition variable. This
types for creating and
allows threads to wait ("sleep") efficiently without
managing threads, mutexes,
wasting CPU time (unlike busy-waiting). When a
condition is met (i.e., the semaphore becomes
and condition variables (e.g.,
available), one of the waiting threads can be "woken
pthread_t, pthread_create,
up."
pthread_mutex_t,
▪ int value: The integer counter of the semaphore. For a
pthread_cond_t). binary semaphore, this will be 1 (available) or 0 (in
use). For a counting semaphore, it can be any non-
negative number.
Create Own Semaphores - Code
▪ pthread_mutex_init(&(sem- ▪ pthread_mutex_lock(&(sem->mutex)): The
>mutex), NULL): Initializes the
thread first locks the semaphore's internal
mutex inside the semaphore struct.
mutex. This ensures that no other thread
The NULL argument specifies default
can check or change sem->value at the
attributes for the mutex.
same time.
▪ pthread_cond_init(&(sem-
>condition), NULL): Initializes the ▪ while (sem->value <= 0): The thread checks
condition variable inside the
if the semaphore is available. If value is 0 or
semaphore struct with default
less, the resource is not available. A while
attributes.
loop is used instead of an if statement to
▪ sem->value = initial_value;: Sets
handle "spurious wakeups" (where a thread
the semaphore's starting count. For
might be woken up even if the condition
a binary semaphore, initial_value
isn't truly met).
will be 1.
Create Own Semaphores - Code
▪ pthread_cond_wait(&(sem-
▪ sem->value--: If the while loop
>condition), &(sem->mutex)): If the
condition was false (or after the thread
resource is not available, the thread
calls this function to go to sleep.
is woken up and the condition becomes
Crucially, this function atomically does
false), it means the resource is
two things:
▪ It unlocks the mutex. This is vital so
available. The thread decrements the
that another thread can call
semaphore's value to mark it as "in
semaphore_signal to release the
resource.
use."
▪ It puts the current thread to sleep until
it is signaled. ▪ pthread_mutex_unlock(&(sem-
▪ When the thread is woken up by a
>mutex)): The thread unlocks the
pthread_cond_signal, it automatically
re-acquires the lock on the mutex before internal mutex, allowing other threads
proceeding.
to interact with the semaphore.
Create Own Semaphores - Code
▪ pthread_mutex_lock(&(sem->mutex)): The ▪ semaphore* sem = (semaphore*)arg;: The arg passed
thread locks the internal mutex to safely from pthread_create is a void pointer. This line casts it
back to its original type, a pointer to a semaphore.
modify the semaphore's value.
▪ semaphore_wait(sem): The thread calls our wait function
▪ sem->value++: It increments the
to request access to the resource. The function will not
semaphore's value, indicating that a
return until the semaphore is acquired.
resource has been freed.
▪ // --- Critical Section Start ---: This marks the beginning of
the code that accesses the shared resource. Only one
▪ pthread_cond_signal(&(sem->condition)):
thread can be in this section at a time.
This function "wakes up" at least one of the
threads that are currently waiting inside ▪ // --- Critical Section End ---: Marks the end of the
pthread_cond_wait. The awakened thread protected code.
will then attempt to re-acquire the mutex
▪ semaphore_signal(sem): After leaving the critical section,
and re-check the while loop condition in
the thread calls signal to release the semaphore, allowing
semaphore_wait.
another waiting thread to proceed.
▪ return NULL;: The function returns a NULL pointer, as it
▪ pthread_mutex_unlock(&(sem->mutex)):
has no specific result to return.
The thread unlocks the internal mutex.
Create Own Semaphores - Code
▪ semaphore sem;: Declares a variable of ▪ &thread: A pointer to store the ID of the new thread.
our custom semaphore type.
▪ NULL: Use default thread attributes.
▪ semaphore_init(&sem, 1);: Initializes ▪ thread_function: The function the new thread will
our semaphore with a value of 1, execute.
making it a binary semaphore that is
▪ (void*)&sem: A pointer to our semaphore, which is
initially available.
passed as an argument to thread_function.
▪ pthread_t thread;: Declares a variable ▪ The main thread then proceeds to compete for the
to hold the thread identifier.
same semaphore by calling semaphore_wait(&sem).
▪ pthread_join(thread, NULL);: The main thread waits
▪ pthread_create(&thread, NULL,
here until the other thread (thread) has finished its
thread_function, (void*)&sem);: This
execution. This ensures the program doesn't exit
function creates and starts a new
thread. prematurely.
▪ return 0;: Indicates that the program has completed
successfully.
Create Own Semaphores - Code
▪ The main program starts.
▪ It creates a semaphore (our key holder) and sets its value to 1 (key available).
▪ It creates a new thread. Now we have two workers: the main thread and the new thread.
▪ Both threads will try to run semaphore_wait to get the key. It's a race!
▪ Whoever gets there first will lock the semaphore, change its value to 0, and enter its "critical
section."
▪ The second thread to arrive will see the value is 0 and will be forced to wait.
▪ The first thread finishes its work, calls semaphore_signal, changes the value back to 1, and rings
the bell.
▪ The waiting second thread wakes up, sees the value is now 1, and finally gets the key to do its
work.
▪ Once both threads are done, the main program cleans up and exits.
Classical Synchronization Problem
▪ The classical synchronization problems in operating systems are
fundamental concurrency issues arising when multiple processes or
threads need coordinated access to shared resources.
▪ These problems illustrate challenges such as avoiding deadlock,
ensuring mutual exclusion, and preventing race conditions.
1. Bounded-Buffer (Producer-Consumer) Problem
2. Dining Philosophers Problem
3. Readers-Writers Problem
4. Sleeping Barber Problem
Bounded-Buffer (Producer-Consumer) Problem
▪ This involves a fixed-size buffer shared between two types of
processes:
▪ Producers, who generate data and place it in the buffer, and
▪ Consumers, who remove data from the buffer.
▪ Synchronization ensures that producers don't add data when the buffer is
full and consumers don't remove data when the buffer is empty.
▪ The challenge is to coordinate access so that no data is lost or corrupted
while ensuring efficient buffer usage.
▪ Semaphores or mutex locks are typically used for this synchronization.
Producer-Consumer – Semaphore Solution
▪ Semaphores ensure proper synchronization by controlling access to the buffer slots and mutually
exclusive operations on shared data structures.
▪ Shared Entities:
▪ A fixed-size buffer to hold produced data.
▪ Two indices: in for the next slot to insert by the producer, and out for the next slot to remove by
the consumer.
▪ Three semaphores:
▪ mutex (binary semaphore) for mutual exclusion to ensure that only one process accesses
the buffer or modifies in/out pointers at a time.
▪ empty (counting semaphore) initialized to the buffer size, representing the number of empty
slots.
▪ full (counting semaphore) initialized to zero, representing the number of filled slots.
Bounded-Buffer (Producer-Consumer) Problem
Initialize
semaphore mutex = 1 // Binary semaphore for mutual exclusion
semaphore empty = BUFFER_SIZE // Counting semaphore for empty slots
semaphore full = 0 // Counting semaphore for filled slots
integer in = 0 // Producer index
integer out = 0 // Consumer index
buffer[BUFFER_SIZE] // Shared circular buffer
Bounded-Buffer (Producer-Consumer) Problem
Producer Process:
while true do Prepare the data to be inserted into the
produce item buffer.
Block if the buffer is full (no empty slots),
wait(empty)
otherwise decrement empty.
Lock to enter the critical section so only
wait(mutex)
one process can modify the buffer.
buffer[in] = item Insert the produced item at index in.
Move in index to the next position
in = (in + 1) mod BUFFER_SIZE
circularly to wrap around.
signal(mutex) Release the lock (exit critical section).
Increment the count of filled slots to notify
signal(full)
the consumer.
Bounded-Buffer (Producer-Consumer) Problem
Consumer Process:
while true do Block if the buffer is empty (no full slots),
wait(Full) otherwise decrement full.
Lock to enter the critical section to safely
wait(mutex)
access the buffer.
item = buffer[out] Remove the item at index out.
Move out index circularly for the next
out = (out + 1) mod BUFFER_SIZE
removal.
signal(mutex) Release the lock (exit critical section).
Increment empty slots count to notify the
signal(empty)
producer.
consume item Process the consumed item.
Producer-Consumer – Semaphore Solution
▪ Producer Process Flow:
▪ Wait (decrement) on empty: Wait for at least one empty slot.
▪ Wait (lock) on mutex: Enter the critical section.
▪ Insert an item into the buffer at index in.
▪ Update in index in circular fashion (e.g. (in + 1) %
BUFFER_SIZE).
▪ Signal (unlock) mutex: Leave critical section.
▪ Signal (increment) full: Increment count of full slots.
Producer-Consumer – Semaphore Solution
▪ Consumer Process Flow:
▪ Wait (decrement) on full: Wait for at least one full slot.
▪ Wait (lock) on mutex: Enter the critical section.
▪ Remove an item from the buffer at index out.
▪ Update out index in circular fashion (e.g. (out + 1) %
BUFFER_SIZE).
▪ Signal (unlock) mutex: Leave critical section.
▪ Signal (increment) empty: Increment count of empty slots.
Dining Philosophers Problem
▪ This models a scenario where multiple philosophers sitting around a
circular table need two shared chopsticks (resources) to eat.
▪ Each philosopher must pick up the two adjacent chopsticks, one at a
time, to eat, leading to potential deadlock or starvation if all pick up
one chopstick simultaneously and wait indefinitely for the other.
▪ The problem highlights resource allocation and deadlock prevention
techniques.
Dining Philosophers Problem
▪ Imagine 5 philosophers sitting around a circular table.
▪ Between each pair of philosophers, there is one chopstick (fork).
▪ Each philosopher alternates between thinking and eating.
▪ To eat, a philosopher needs both the chopsticks on their left and right.
▪ Since chopsticks are shared, a philosopher can only pick up a
chopstick if it is not already being used by a neighbor.
▪ After eating, the philosopher puts down both chopsticks and returns
to thinking.
Dining Philosophers Problem
▪ What Problems to be Avoided:
▪ Deadlock: If every philosopher picks up the chopstick on their left
simultaneously, then all wait forever for the right chopstick to become
free. This circular waiting causes a deadlock, and no one can eat.
▪ Starvation: Some philosophers may wait indefinitely if others
continuously get access to the chopsticks, leading to unfair resource
allocation.
▪ Mutual Exclusion: Ensuring that no two adjacent philosophers eat at
the same time so that no chopstick is shared simultaneously is critical.
Dining Philosophers Problem
semaphore chopstick[5]; // One semaphore per chopstick, initialized to 1
semaphore mutex; // Semaphore to limit number of philosophers at the table
initialize all chopstick[i] to 1
initialize mutex to 4 // Allow maximum 4 philosophers to try picking chopsticks
Dining Philosophers Problem
function philosopher(i):
while true:
think()
Each philosopher spends some time thinking (not competing for chopsticks).
Dining Philosophers Problem
wait(mutex) // Request to enter - limit philosophers to 4
▪ Philosopher requests permission to try eating from the "dining room".
▪ Since the mutex semaphore allows only up to 4 philosophers, this prevents
all 5 trying to eat at the same time, breaking the circular wait.
Dining Philosophers Problem
wait(chopstick[i]) // Pick left chopstick
wait(chopstick[(i + 1) % 5]) // Pick right chopstick
Philosopher tries to pick up the left chopstick by waiting on its semaphore.
Philosopher then tries to pick up the right chopstick (using modulo for
circular seating).
If the chopstick is in use, the philosopher waits until it is free.
Dining Philosophers Problem
eat()
Philosopher eats now that both chopsticks are acquired.
signal(chopstick[i]) // Put down left chopstick
signal(chopstick[(i + 1) % 5]) // Put down right chopstick
Philosopher puts down left and right chopsticks, signaling availability to
others.
Dining Philosophers Problem
signal(mutex) // Philosopher leaves the table - allows another to enter
Philosopher signals the mutex semaphore to indicate they have finished trying
to eat.
This allows another philosopher to enter the dining room and attempt to eat,
maintaining the limit of 4.
Readers-Writers Problem
▪ This problem deals with a shared database accessed by two types of
processes:
▪ Readers, which can concurrently read the data without conflict,
and
▪ Writers, which require exclusive access to modify the data.
▪ The challenge is to ensure that multiple readers can access the data
simultaneously, but writers have exclusive access, preventing
inconsistent reads or writes.
▪ Synchronization mechanisms manage these constraints to avoid race
conditions and starvation.
Readers-Writers Problem
▪ The Readers-Writers Problem involves multiple processes (or threads)
that want to access a shared resource (like a file or database):
▪ Readers can read the resource simultaneously because reading does
not change data.
▪ Writers need exclusive access — only one writer at a time and no
readers should read while writing, to prevent inconsistent or corrupted
data.
Readers-Writers Problem
▪ Concerns Addressed Using Semaphores:
▪ Mutual exclusion for writers to prevent data corruption.
▪ Allowing multiple readers to read simultaneously.
▪ Ensuring writers have exclusive access (no readers or other writers).
▪ Preventing starvation of readers or writers by managing access
fairness.
Readers-Writers Problem
Initialize semaphores and counter
mutex semaphore controls mutual exclusion for
Semaphore mutex = 1
incrementing/decrementing readCount safely.
write semaphore ensures exclusive access for
Semaphore write = 1
writers (and blocks readers when held).
readCount tracks how many readers are
Integer readCount = 0
currently reading.
function reader(): wait(mutex): Enter critical section to update
wait(mutex) readCount.
readCount++: Increment number of active
readCount = readCount + 1
readers.
If this is the first reader, wait(write) is called to
if readCount == 1
lock out writers (block writing).
wait(write)
signal(mutex): Exit critical section on
signal(mutex)
readCount.
Readers-Writers Problem
// Critical section: reading resource // Reader performs reading (critical section).
After reading, wait(mutex) is called to enter
wait(mutex)
critical section again for updating readCount.
Semaphore write = 1
readCount--: Decrement number of active
readCount = readCount - 1
readers.
If this is the last reader leaving, signal(write)
if readCount == 0
releases write semaphore to allow writers to
signal(write)
proceed.
signal(mutex)
signal(mutex): Exit critical section.
Readers-Writers Problem
Writer Process:
function writer(): Acquire exclusive access — no other writer or
wait(write) reader can enter critical section.
// Critical section: writing resource Write to shared resource (critical section).
signal(write) Release exclusive access for others.
Readers-Writers Problem - Tracing
▪ Initial State:
▪ mutex = 1 (protects readCount)
▪ write = 1 (exclusive access for writers)
▪ readCount = 0
▪ Step 1: First Reader Enters
▪ Reader calls wait(mutex) → decrements mutex from 1 to 0.
▪ Reader increments readCount from 0 to 1.
▪ Since readCount == 1, reader calls wait(write) → decrements write from 1 to 0 (blocks writers).
▪ Reader calls signal(mutex) → increments mutex back to 1.
▪ Reader accesses the resource for reading.
▪ Semaphore values:
▪ mutex = 1
▪ write = 0
▪ readCount = 1
Readers-Writers Problem - Tracing
▪ Step 2: Second Reader Enters (Concurrent Reading Allowed)
▪ Reader calls wait(mutex) → mutex goes 1 → 0.
▪ Reader increments readCount from 1 to 2.
▪ Since readCount != 1, no call to wait(write).
▪ Reader calls signal(mutex) → increments mutex to 1.
▪ Reader accesses resource simultaneously with the first reader.
▪ Semaphore values:
▪ mutex = 1
▪ write = 0
▪ readCount = 2
Readers-Writers Problem - Tracing
▪ Step 3: Writer Attempts to Enter
▪ Writer tries wait(write).
▪ Since write is 0, writer blocks waiting for the semaphore.
▪ Writer is blocked here until all readers finish.
▪ Step 4: First Reader Leaves
▪ Reader calls wait(mutex) → mutex 1 → 0.
▪ Reader decrements readCount from 2 to 1.
▪ Since readCount != 0, no signal on write.
▪ Reader calls signal(mutex) → mutex 0 → 1.
▪ Semaphore values:
▪ mutex = 1
▪ write = 0
▪ readCount = 1
Readers-Writers Problem - Tracing
▪ Step 5: Last Reader Leaves
▪ Reader calls wait(mutex) → mutex 1 → 0.
▪ Reader decrements readCount from 1 to 0.
▪ Since readCount == 0, reader calls signal(write) → increments write
semaphore from 0 to 1, unblocking one waiting writer.
▪ Reader calls signal(mutex) → mutex 0 → 1.
▪ Semaphore values:
▪ mutex = 1
▪ write = 1
▪ readCount = 0
Readers-Writers Problem - Tracing
▪ Step 6: Writer Proceeds
▪ Writer now successfully performs wait(write) → decrements write 1 → 0,
entering critical section exclusively.
▪ Writer writes to resource.
▪ Semaphore values:
▪ mutex = 1
▪ write = 0 (Writer holds access exclusively)
▪ readCount = 0
Sleeping Barber Problem
▪ This problem models a barber shop where one barber serves
customers.
▪ If no customers are present, the barber sleeps;
▪ when a customer arrives, the barber wakes to give a haircut.
▪ Customers either wait if there are available waiting chairs or leave if
the shop is full.
▪ Synchronization ensures proper coordination of customer arrivals,
waiting, and service without loss or deadlock.